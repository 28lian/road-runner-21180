            //Drop point position
            Pose2d dropPose = new Pose2d(-39, 15, 0.45);
            //Park positions
            Pose2d[] parkPose = {new Pose2d(-11, 11, 0), new Pose2d(-35, 11, 0), new Pose2d(-59, 11, 0)};

            //Cone Stack pick up position
            Pose2d stackPose = new Pose2d(-60, 11, 0);

            ElapsedTime clock = new ElapsedTime();

            double time = 0;
            double dropTrajTime = 1000;
            double retractTime = 1000;
            double doneTime = 1000;

            boolean endDropTraj = false; // true if drop trajectory has completed
            boolean dropTrajDone = false; // true if drop trajectory has completed
            boolean traj5Done = false; //true if parking trajectory has completed
            boolean atConeStackPosition = false; //True if robot at stack position
            boolean parkCompleted = false; //True if parking is completed
            boolean coneAvailableForDrop = false; // True of cone has been picked up from stack


            int cycles = 0;
            int state = 0;
            int cycles = 0; //Number cone cycles completed
            int state = 0; // state machine to pick up the cone

            TrajectorySequence traj1; //From start to drop point
            TrajectorySequence traj2; //From drop to stack
            TrajectorySequence traj3; //From stack to drop
            TrajectorySequence[] traj5; //From drop to park

@Override
public void initialize() {
        //Start to drop point
        traj1 = robot.drive.trajectorySequenceBuilder(initPose())
        .splineTo(new Vector2d(-35, 40), -PI / 2)
        .lineTo(new Vector2d(-35, 25))
        .setAccelConstraint(SampleMecanumDrive.getAccelerationConstraint(25))
        .splineToSplineHeading(dropPose, 2)
        .waitSeconds(0.3)//Waiting for the cone drop
        .resetConstraints()
        .addTemporalMarker(1, -0.7, () -> {
        robot.extendLiftProfile(time, liftMedClose[0], 0);
        })
        .waitSeconds(0.5)//Allows the cone to fall
        .addTemporalMarker(1, 0, () -> {
        endDropTraj = true;
        dropTrajDone = true;
        atConeStackPosition = false;
        dropTrajTime = time;
        }
        )
        .build();

        //Drop point to stack
        traj2 = robot.drive.trajectorySequenceBuilder(dropPose)
        .setVelConstraint(SampleMecanumDrive.getVelocityConstraint(30, DriveConstants.MAX_ANG_VEL, DriveConstants.TRACK_WIDTH))
        .setReversed(true)
        .splineTo(stackPose.vec(), stackPose.getHeading() + PI)
        .addDisplacementMarker(() -> {
        //Med, grab position
        robot.extendLiftProfile(time, liftMedClose[0], 0);
        robot.arm.moveToGrabPosition(time);
        robot.claw.openClaw(time);
        })
        .addTemporalMarker(1, 0, () -> {
        atConeStackPosition = true;
        endDropTraj = false;
        dropTrajDone = false;
        })
        .build();

        //Stack to the drop point
        traj3 = robot.drive.trajectorySequenceBuilder(stackPose)
        .setVelConstraint(SampleMecanumDrive.getVelocityConstraint(10, DriveConstants.MAX_ANG_VEL, DriveConstants.TRACK_WIDTH))
        .splineTo(dropPose.vec(), dropPose.getHeading())
        .addTemporalMarker(1, -1, () -> {
        robot.extendLiftProfile(time, liftMedClose[0], 0);
        //Arm in drop position
        })
        .addTemporalMarker(1, 0, () -> {
        endDropTraj = true;
        dropTrajDone = true;
        atConeStackPosition = false;
        dropTrajTime = time;
        cycles++;
        })
        .build();

        //Drop point to park
        traj5 = new TrajectorySequence[]{
        robot.drive.trajectorySequenceBuilder(dropPose)
        .setReversed(true)
        .splineTo(parkPose[2].vec(), PI)
        .lineTo(parkPose[0].vec())
        .addTemporalMarker(1, 0, () -> {
        traj5Done = true;
        })
        .build(),
        robot.drive.trajectorySequenceBuilder(dropPose)
        .setReversed(true)
        .splineTo(parkPose[2].vec(), PI)
        .lineTo(parkPose[1].vec())
        .addTemporalMarker(1, 0, () -> {
        traj5Done = true;
        })
        .build(),
        robot.drive.trajectorySequenceBuilder(dropPose)
        .setReversed(true)
        .splineTo(parkPose[2].vec(), PI)
        .addTemporalMarker(1, 0, () -> {
        traj5Done = true;
        })
        .build()